use crate::filedb::*;
use codespan_reporting::diagnostic::{Diagnostic, Label};
use codespan_reporting::term::termcolor::{ColorChoice, StandardStream};
use core::marker::PhantomData;
use core::ptr::null_mut;
use core::sync::atomic::{AtomicPtr, AtomicU64, Ordering};
use lazy_static::lazy_static;
use std::fmt::Write;
use std::{fmt, str};

#[derive(Debug, Clone, Copy)]
pub struct CompilerLoc {
    pub file: &'static str,
    pub line: u32,
}

macro_rules! here {
    () => {{
        $crate::util::CompilerLoc {
            file: core::file!(),
            line: core::line!(),
        }
    }};
}

#[derive(Debug)]
pub struct Error {
    pub info: &'static str,
    pub message: Option<String>,
    pub begin: usize,
    pub end: usize,
    pub file: u32,
    #[cfg(debug_assertions)]
    pub compiler_loc: CompilerLoc,
}

impl Error {
    pub fn render(&self, files: &FileDb) -> String {
        use crate::util::*;
        use codespan_reporting::term;

        let mut out = StringWriter::new();
        write!(out, "{}", self.info).unwrap();

        if cfg!(debug_assertions) {
            let loc = self.compiler_loc;
            write!(out, " (generated by {}:{})", loc.file, loc.line).unwrap();
        }
        let info = out.flush_string();

        let config = codespan_reporting::term::Config::default();
        let diagnostic = Diagnostic::error()
            .with_labels(vec![Label::primary(self.file, self.begin..self.end)])
            .with_message(info)
            .with_notes(self.message.clone().map(|a| vec![a]).unwrap_or(Vec::new()));

        let writer = StandardStream::stderr(ColorChoice::Always);
        term::emit(&mut writer.lock(), &config, files, &diagnostic).unwrap();

        return out.into_string();
    }
}

pub struct StringWriter {
    buf: Vec<u8>,
}

impl StringWriter {
    pub fn new() -> StringWriter {
        StringWriter {
            buf: Vec::with_capacity(8 * 1024),
        }
    }

    pub fn into_string(self) -> String {
        return unsafe { String::from_utf8_unchecked(self.buf) };
    }

    pub fn to_string(&self) -> String {
        return unsafe { String::from_utf8_unchecked(self.buf.clone()) };
    }

    pub fn as_str(&self) -> &str {
        return unsafe { str::from_utf8_unchecked(&self.buf) };
    }

    pub fn flush_string(&mut self) -> String {
        let ret_val = unsafe { String::from_utf8_unchecked(self.buf.clone()) };
        self.buf.clear();
        return ret_val;
    }
}

impl fmt::Write for StringWriter {
    fn write_str(&mut self, buf: &str) -> fmt::Result {
        self.buf.extend_from_slice(buf.as_bytes());
        return Ok(());
    }
}

pub struct SharedRef<T> {
    pub ptr: AtomicPtr<T>,
}

impl<T> SharedRef<T> {
    pub fn new() -> Self {
        Self {
            ptr: AtomicPtr::new(null_mut()),
        }
    }

    #[inline]
    pub fn try_use(&self) -> Option<&'static T> {
        return unsafe { self.ptr.load(Ordering::SeqCst).as_ref() };
    }

    #[inline]
    pub fn leaky_store(&self, data: &'static T) -> &'static T {
        while let Err(ptr) = self.ptr.compare_exchange_weak(
            null_mut(),
            data as *const T as *mut T,
            Ordering::SeqCst,
            Ordering::SeqCst,
        ) {
            if ptr != null_mut() {
                return unsafe { &*ptr };
            }
        }

        return data;
    }
}

impl<T: 'static> core::ops::Deref for SharedRef<T> {
    type Target = T;

    fn deref(&self) -> &T {
        return self.try_use().unwrap();
    }
}

#[derive(Clone, Copy)]
#[repr(C)]
pub struct Spanned<T> {
    // TODO these could be u32's probably
    // TODO should this be a generic wrapper or just put as fields?
    // TODO maybe this should like, hold hashes or something for caching
    pub inner: T,
    pub begin: usize,
    pub end: usize,
}

impl<T: fmt::Debug> fmt::Debug for Spanned<T> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        return self.inner.fmt(fmt);
    }
}

pub fn span<T>(inner: T, begin: usize, end: usize) -> Spanned<T> {
    return Spanned {
        inner,
        begin: begin,
        end: end,
    };
}

#[repr(transparent)]
pub struct Id(u64);

impl fmt::Debug for Id {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        return self.value().fmt(fmt);
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum IdValue {
    Name(u64),
    Type(u64),
    Var(u64),
}

impl Id {
    // top 4 bits used for type
    const NAME: u64 = 0b0000_0000u64.reverse_bits();
    const TYPE: u64 = 0b0000_0001u64.reverse_bits();
    const VAR: u64 = 0b0000_0010u64.reverse_bits();
    const RESERVED: u64 = 0b0000_1111u64.reverse_bits();

    pub fn new(id: IdValue) -> Self {
        return Self(Self::translate(id));
    }

    pub fn value(&self) -> IdValue {
        let value = self.0 & !Self::RESERVED;
        return match self.0 & Self::RESERVED {
            Self::NAME => IdValue::Name(value),
            Self::TYPE => IdValue::Type(value),
            Self::VAR => IdValue::Var(value),
            x => panic!(
                "tag had value: 0b{:b} (reversed=0b{:b})",
                x,
                x.reverse_bits()
            ),
        };
    }

    fn translate(id: IdValue) -> u64 {
        let (label, value) = match id {
            IdValue::Name(v) => (Self::NAME, v),
            IdValue::Type(v) => (Self::TYPE, v),
            IdValue::Var(v) => (Self::VAR, v),
        };

        assert!((value & Self::RESERVED) == 0, "id was: {:?}", value);
        return label | value;
    }
}

pub struct StackLL<'a, E> {
    pub parent: Option<&'a StackLL<'a, E>>,
    pub item: E,
}

impl<'a, E> StackLL<'a, E> {
    pub fn new(item: E) -> Self {
        Self { parent: None, item }
    }

    pub fn get(&self) -> &E {
        &self.item
    }

    pub fn child<'b>(&'b self, item: E) -> StackLL<'b, E>
    where
        'a: 'b,
    {
        StackLL {
            parent: Some(self),
            item,
        }
    }
}

pub struct StackLLIter<'a, 'b, E>
where
    'b: 'a,
{
    pub ll: Option<&'a StackLL<'b, E>>,
}

impl<'a, 'b, E> Iterator for StackLLIter<'a, 'b, E> {
    type Item = &'a E;
    fn next(&mut self) -> Option<&'a E> {
        let ll = self.ll?;
        let item = &ll.item;
        self.ll = ll.parent;
        return Some(item);
    }
}

impl<'a, 'b, E> IntoIterator for &'a StackLL<'b, E> {
    type Item = &'a E;
    type IntoIter = StackLLIter<'a, 'b, E>;

    fn into_iter(self) -> Self::IntoIter {
        StackLLIter { ll: Some(self) }
    }
}
