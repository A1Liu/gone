use crate::filedb::*;
use codespan_reporting::diagnostic::{Diagnostic, Label};
use codespan_reporting::term::termcolor::{ColorChoice, StandardStream};
use core::marker::PhantomData;
use core::ptr::null_mut;
use core::sync::atomic::{AtomicPtr, AtomicUsize, Ordering};
use lazy_static::lazy_static;
use std::fmt::Write;
use std::{fmt, str};

#[derive(Debug, Clone, Copy)]
pub struct CompilerLoc {
    pub file: &'static str,
    pub line: u32,
}

macro_rules! here {
    () => {{
        $crate::util::CompilerLoc {
            file: core::file!(),
            line: core::line!(),
        }
    }};
}

#[derive(Debug)]
pub struct Error {
    pub info: &'static str,
    pub message: Option<String>,
    pub begin: usize,
    pub end: usize,
    pub file: u32,
    #[cfg(debug_assertions)]
    pub compiler_loc: CompilerLoc,
}

impl Error {
    pub fn render(&self, files: &FileDb) -> String {
        use crate::util::*;
        use codespan_reporting::term;

        let mut out = StringWriter::new();
        write!(out, "{}", self.info).unwrap();

        if cfg!(debug_assertions) {
            let loc = self.compiler_loc;
            write!(out, " (generated by {}:{})", loc.file, loc.line).unwrap();
        }
        let info = out.flush_string();

        let config = codespan_reporting::term::Config::default();
        let diagnostic = Diagnostic::error()
            .with_labels(vec![Label::primary(self.file, self.begin..self.end)])
            .with_message(info)
            .with_notes(self.message.clone().map(|a| vec![a]).unwrap_or(Vec::new()));

        let writer = StandardStream::stderr(ColorChoice::Always);
        term::emit(&mut writer.lock(), &config, files, &diagnostic).unwrap();

        return out.into_string();
    }
}

pub struct StringWriter {
    buf: Vec<u8>,
}

impl StringWriter {
    pub fn new() -> StringWriter {
        StringWriter {
            buf: Vec::with_capacity(8 * 1024),
        }
    }

    pub fn into_string(self) -> String {
        return unsafe { String::from_utf8_unchecked(self.buf) };
    }

    pub fn to_string(&self) -> String {
        return unsafe { String::from_utf8_unchecked(self.buf.clone()) };
    }

    pub fn as_str(&self) -> &str {
        return unsafe { str::from_utf8_unchecked(&self.buf) };
    }

    pub fn flush_string(&mut self) -> String {
        let ret_val = unsafe { String::from_utf8_unchecked(self.buf.clone()) };
        self.buf.clear();
        return ret_val;
    }
}

impl fmt::Write for StringWriter {
    fn write_str(&mut self, buf: &str) -> fmt::Result {
        self.buf.extend_from_slice(buf.as_bytes());
        return Ok(());
    }
}

pub struct SharedRef<T> {
    pub ptr: AtomicPtr<T>,
}

impl<T> SharedRef<T> {
    pub fn new() -> Self {
        Self {
            ptr: AtomicPtr::new(null_mut()),
        }
    }

    #[inline]
    pub fn try_use(&self) -> Option<&'static T> {
        return unsafe { self.ptr.load(Ordering::SeqCst).as_ref() };
    }

    #[inline]
    pub fn leaky_store(&self, data: &'static T) -> &'static T {
        while let Err(ptr) = self.ptr.compare_exchange_weak(
            null_mut(),
            data as *const T as *mut T,
            Ordering::SeqCst,
            Ordering::SeqCst,
        ) {
            if ptr != null_mut() {
                return unsafe { &*ptr };
            }
        }

        return data;
    }
}

impl<T: 'static> core::ops::Deref for SharedRef<T> {
    type Target = T;

    fn deref(&self) -> &T {
        return self.try_use().unwrap();
    }
}

#[derive(Clone, Copy)]
#[repr(C)]
pub struct Spanned<T> {
    // TODO these could be u32's probably
    // TODO should this be a generic wrapper or just put as fields?
    pub inner: T,
    pub begin: usize,
    pub end: usize,
}

impl<T: fmt::Debug> fmt::Debug for Spanned<T> {
    fn fmt(&self, fmt: &mut fmt::Formatter) -> Result<(), fmt::Error> {
        return self.inner.fmt(fmt);
    }
}

pub fn span<T>(inner: T, begin: usize, end: usize) -> Spanned<T> {
    return Spanned {
        inner,
        begin: begin,
        end: end,
    };
}
