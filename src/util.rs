use crate::filedb::*;
use codespan_reporting::diagnostic::{Diagnostic, Label};
use codespan_reporting::term::termcolor::{ColorChoice, StandardStream};
use std::fmt::Write;
use std::{fmt, str};

#[derive(Debug, Clone, Copy)]
pub struct CompilerLoc {
    pub file: &'static str,
    pub line: u32,
}

macro_rules! here {
    () => {{
        $crate::util::CompilerLoc {
            file: core::file!(),
            line: core::line!(),
        }
    }};
}

#[derive(Debug)]
pub struct Error {
    pub info: &'static str,
    pub message: Option<String>,
    pub begin: usize,
    pub end: usize,
    pub file: u32,
    #[cfg(debug_assertions)]
    pub compiler_loc: CompilerLoc,
}

impl Error {
    pub fn render(&self, files: &FileDb) -> String {
        use crate::util::*;
        use codespan_reporting::term;

        let mut out = StringWriter::new();
        write!(out, "{}", self.info).unwrap();

        if cfg!(debug_assertions) {
            let loc = self.compiler_loc;
            write!(out, " (generated by {}:{})", loc.file, loc.line).unwrap();
        }
        let info = out.flush_string();

        let config = codespan_reporting::term::Config::default();
        let diagnostic = Diagnostic::error()
            .with_labels(vec![Label::primary(self.file, self.begin..self.end)])
            .with_message(info)
            .with_notes(self.message.clone().map(|a| vec![a]).unwrap_or(Vec::new()));

        let writer = StandardStream::stderr(ColorChoice::Always);
        term::emit(&mut writer.lock(), &config, files, &diagnostic).unwrap();

        return out.into_string();
    }
}

pub struct StringWriter {
    buf: Vec<u8>,
}

impl StringWriter {
    pub fn new() -> StringWriter {
        StringWriter {
            buf: Vec::with_capacity(8 * 1024),
        }
    }

    pub fn into_string(self) -> String {
        return unsafe { String::from_utf8_unchecked(self.buf) };
    }

    pub fn to_string(&self) -> String {
        return unsafe { String::from_utf8_unchecked(self.buf.clone()) };
    }

    pub fn as_str(&self) -> &str {
        return unsafe { str::from_utf8_unchecked(&self.buf) };
    }

    pub fn flush_string(&mut self) -> String {
        let ret_val = unsafe { String::from_utf8_unchecked(self.buf.clone()) };
        self.buf.clear();
        return ret_val;
    }
}

impl fmt::Write for StringWriter {
    fn write_str(&mut self, buf: &str) -> fmt::Result {
        self.buf.extend_from_slice(buf.as_bytes());
        return Ok(());
    }
}
